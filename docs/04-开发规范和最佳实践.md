# 开发规范和最佳实践

## 1. 概述

### 1.1 目标
建立统一的开发规范，确保代码质量、可维护性和团队协作效率。

### 1.2 适用范围
- React Native + Expo 应用开发
- TypeScript 代码编写
- 组件设计和架构
- 状态管理
- 数据库操作
- 文件组织

## 2. 代码规范

### 2.1 TypeScript 规范

#### 2.1.1 类型定义
```typescript
// ✅ 正确：使用接口定义对象类型
interface Video {
  id: string;
  title: string;
  duration: number;
  createdAt: Date;
}

// ✅ 正确：使用类型别名定义联合类型
type VideoStatus = 'loading' | 'playing' | 'paused' | 'error';

// ✅ 正确：使用泛型定义函数类型
interface VideoService {
  getVideoById<T extends string>(id: T): Promise<Video>;
  searchVideos(query: string): Promise<Video[]>;
}

// ❌ 避免：使用 any 类型
function processVideo(video: any) { // ❌
  // ...
}

// ✅ 推荐：使用 unknown 或具体类型
function processVideo(video: unknown) { // ✅
  if (isVideo(video)) {
    // ...
  }
}
```

#### 2.1.2 函数类型
```typescript
// ✅ 正确：明确的参数和返回类型
async function fetchVideo(id: string): Promise<Video | null> {
  const response = await api.get(`/videos/${id}`);
  return response.data;
}

// ✅ 正确：使用接口定义复杂函数参数
interface UpdateVideoOptions {
  title?: string;
  description?: string;
  tags?: string[];
}

async function updateVideo(id: string, options: UpdateVideoOptions): Promise<Video> {
  // ...
}

// ✅ 正确：使用泛型约束
function createVideo<T extends Partial<Video>>(data: T): Promise<Video> {
  // ...
}
```

### 2.2 React 组件规范

#### 2.2.1 函数组件
```typescript
// ✅ 正确：使用函数组件和 TypeScript
interface VideoPlayerProps {
  video: Video;
  onPlay?: () => void;
  onPause?: () => void;
  className?: string;
}

export const VideoPlayer: React.FC<VideoPlayerProps> = ({
  video,
  onPlay,
  onPause,
  className
}) => {
  const [isPlaying, setIsPlaying] = useState(false);
  
  const handlePlay = useCallback(() => {
    setIsPlaying(true);
    onPlay?.();
  }, [onPlay]);
  
  return (
    <View className={clsx('video-player', className)}>
      <Video
        source={{ uri: video.filePath }}
        resizeMode={ResizeMode.CONTAIN}
        onPlaybackStatusUpdate={handlePlaybackStatusUpdate}
      />
      <VideoControls
        isPlaying={isPlaying}
        onPlay={handlePlay}
        onPause={onPause}
      />
    </View>
  );
};
```

#### 2.2.2 Hooks 规范
```typescript
// ✅ 正确：自定义 Hook 命名和类型
function useVideoPlayer(video: Video | null) {
  const [status, setStatus] = useState<PlaybackStatus>({
    isPlaying: false,
    position: 0,
    duration: 0,
  });
  
  const videoRef = useRef<Video>(null);
  
  useEffect(() => {
    if (!video) return;
    
    const loadVideo = async () => {
      try {
        await videoRef.current?.loadAsync({ uri: video.filePath });
      } catch (error) {
        console.error('Failed to load video:', error);
      }
    };
    
    loadVideo();
  }, [video]);
  
  const play = useCallback(async () => {
    await videoRef.current?.playAsync();
    setStatus(prev => ({ ...prev, isPlaying: true }));
  }, []);
  
  const pause = useCallback(async () => {
    await videoRef.current?.pauseAsync();
    setStatus(prev => ({ ...prev, isPlaying: false }));
  }, []);
  
  return {
    status,
    videoRef,
    play,
    pause,
  };
}

// ✅ 正确：使用自定义 Hook
const { status, play, pause } = useVideoPlayer(currentVideo);
```

### 2.3 样式规范

#### 2.3.1 NativeWind (Tailwind CSS)
```typescript
// ✅ 正确：使用 NativeWind 类名
<View className="flex-1 bg-gray-900 p-4">
  <Text className="text-white text-lg font-semibold">
    {video.title}
  </Text>
  <View className="mt-2 h-px bg-gray-700" />
</View>

// ✅ 正确：使用条件样式
<View className={clsx(
  'rounded-lg p-4',
  isPlaying ? 'bg-blue-500' : 'bg-gray-700',
  className
)}>
  <Text className={clsx(
    'text-sm',
    isPlaying ? 'text-white' : 'text-gray-300'
  )}>
    {video.title}
  </Text>
</View>

// ✅ 正确：使用样式变量
const buttonVariants = cva(
  'rounded-lg px-4 py-2 font-medium transition-colors',
  {
    variants: {
      variant: {
        default: 'bg-blue-600 text-white hover:bg-blue-700',
        secondary: 'bg-gray-700 text-gray-300 hover:bg-gray-600',
        ghost: 'hover:bg-gray-800 text-gray-300',
      },
      size: {
        default: 'h-10',
        sm: 'h-8',
        lg: 'h-12',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

interface ButtonProps extends React.ComponentPropsWithoutRef<typeof Pressable> {
  variant?: VariantProps<typeof buttonVariants>['variant'];
  size?: VariantProps<typeof buttonVariants>['size'];
}

const Button = React.forwardRef<PressableRef, ButtonProps>(
  ({ className, variant, size, ...props }, ref) => {
    return (
      <Pressable
        ref={ref}
        className={clsx(buttonVariants({ variant, size }), className)}
        {...props}
      />
    );
  }
);
```

## 3. 状态管理规范

### 3.1 Zustand Store 设计

#### 3.1.1 Store 结构
```typescript
// ✅ 正确：模块化 Store 设计
interface VideoStore {
  // State
  videos: Video[];
  currentVideo: Video | null;
  playbackState: PlaybackState;
  favorites: Set<string>;
  searchQuery: string;
  
  // Actions
  // Video management
  addVideo: (video: Video) => void;
  removeVideo: (videoId: string) => void;
  updateVideo: (videoId: string, updates: Partial<Video>) => void;
  setCurrentVideo: (video: Video | null) => void;
  
  // Playback control
  playVideo: (videoId: string) => void;
  pauseVideo: () => void;
  updateProgress: (position: number) => void;
  
  // Favorites management
  toggleFavorite: (videoId: string) => void;
  addToFavorites: (videoId: string) => void;
  removeFromFavorites: (videoId: string) => void;
  
  // Search and filter
  setSearchQuery: (query: string) => void;
  clearFilters: () => void;
}

// ✅ 正确：使用 persist 中间件
export const useVideoStore = create<VideoStore>()(
  persist(
    (set, get) => ({
      videos: [],
      currentVideo: null,
      playbackState: {
        isPlaying: false,
        position: 0,
        duration: 0,
        volume: 1.0,
        playbackRate: 1.0,
      },
      favorites: new Set(),
      searchQuery: '',
      
      addVideo: (video) => set((state) => ({
        videos: [...state.videos, video]
      })),
      
      removeVideo: (videoId) => set((state) => ({
        videos: state.videos.filter(v => v.id !== videoId)
      })),
      
      setCurrentVideo: (video) => set({ currentVideo: video }),
      
      playVideo: (videoId) => {
        const video = get().videos.find(v => v.id === videoId);
        if (video) {
          set({ currentVideo: video, playbackState: { ...get().playbackState, isPlaying: true } });
        }
      },
      
      toggleFavorite: (videoId) => set((state) => {
        const newFavorites = new Set(state.favorites);
        if (newFavorites.has(videoId)) {
          newFavorites.delete(videoId);
        } else {
          newFavorites.add(videoId);
        }
        return { favorites: newFavorites };
      }),
    }),
    {
      name: 'video-storage',
      storage: createJSONStorage(() => AsyncStorage),
      partialize: (state) => ({
        favorites: Array.from(state.favorites),
        searchQuery: state.searchQuery,
      }),
    }
  )
);
```

#### 3.1.2 状态选择器
```typescript
// ✅ 正确：使用选择器优化性能
const useCurrentVideo = () => useVideoStore((state) => state.currentVideo);
const useIsPlaying = () => useVideoStore((state) => state.playbackState.isPlaying);
const useFavoriteVideos = () => useVideoStore((state) => 
  state.videos.filter(video => state.favorites.has(video.id))
);

// ✅ 正确：复杂状态选择器
const useFilteredVideos = () => useVideoStore((state) => {
  const { videos, searchQuery, currentCategory } = state;
  
  return videos.filter(video => {
    const matchesSearch = !searchQuery || 
      video.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
      video.tags.some(tag => tag.toLowerCase().includes(searchQuery.toLowerCase()));
    
    const matchesCategory = !currentCategory || video.category === currentCategory;
    
    return matchesSearch && matchesCategory;
  });
});
```

## 4. 数据库操作规范

### 4.1 Drizzle ORM 规范

#### 4.1.1 Schema 定义
```typescript
// ✅ 正确：明确的 Schema 定义
import { sqliteTable, text, integer, boolean } from 'drizzle-orm/sqlite-core';
import { createId } from '@paralleldrive/cuid2';

export const videos = sqliteTable('videos', {
  id: text('id').$defaultFn(() => createId()).primaryKey(),
  title: text('title').notNull(),
  file_path: text('file_path').notNull().unique(),
  thumbnail_path: text('thumbnail_path'),
  duration: integer('duration').notNull(),
  file_size: integer('file_size').notNull(),
  format: text('format').notNull(),
  width: integer('width'),
  height: integer('height'),
  created_at: text('created_at').default(sql`CURRENT_TIMESTAMP`),
  updated_at: text('updated_at').default(sql`CURRENT_TIMESTAMP`),
  tags: text('tags').default('[]'), // JSON array
  category: text('category').default('uncategorized'),
  watch_progress: integer('watch_progress').default(0),
  is_favorite: boolean('is_favorite').default(false),
  play_count: integer('play_count').default(0),
});

// ✅ 正确：类型导出
export type Video = typeof videos.$inferSelect;
export type NewVideo = typeof videos.$inferInsert;
export type UpdateVideo = Partial<NewVideo>;
```

#### 4.1.2 查询操作
```typescript
// ✅ 正确：类型安全的查询
export async function getVideoById(id: string): Promise<Video | null> {
  const [video] = await db.select().from(videos).where(eq(videos.id, id));
  return video || null;
}

// ✅ 正确：分页查询
export async function getVideosPaginated(
  page: number,
  pageSize: number,
  options: {
    category?: string;
    searchQuery?: string;
    sortBy?: 'created_at' | 'title' | 'duration';
    sortOrder?: 'asc' | 'desc';
  } = {}
) {
  const offset = (page - 1) * pageSize;
  const { category, searchQuery, sortBy = 'created_at', sortOrder = 'desc' } = options;
  
  let query = db.select().from(videos);
  
  // 过滤条件
  if (category) {
    query = query.where(eq(videos.category, category));
  }
  
  if (searchQuery) {
    query = query.where(or(
      ilike(videos.title, `%${searchQuery}%`),
      ilike(videos.description, `%${searchQuery}%`)
    ));
  }
  
  // 排序
  const orderByColumn = {
    created_at: videos.created_at,
    title: videos.title,
    duration: videos.duration,
  }[sortBy];
  
  const orderByDirection = sortOrder === 'desc' ? desc : asc;
  query = query.orderBy(orderByDirection(orderByColumn));
  
  // 执行查询
  const items = await query.limit(pageSize).offset(offset);
  
  // 获取总数
  const [totalCount] = await db.select({ 
    count: sql<number>`COUNT(*)` 
  }).from(query.as('count_query'));
  
  return {
    items,
    total: totalCount.count,
    page,
    pageSize,
    hasNext: offset + pageSize < totalCount.count,
    hasPrev: page > 1,
  };
}
```

#### 4.1.3 事务处理
```typescript
// ✅ 正确：事务处理
export async function importVideos(videoDataList: NewVideo[]): Promise<Video[]> {
  return db.transaction(async (tx) => {
    const importedVideos: Video[] = [];
    
    for (const videoData of videoDataList) {
      const [video] = await tx.insert(videos).values(videoData).returning();
      importedVideos.push(video);
      
      // 生成缩略图
      const thumbnailPath = await generateThumbnail(video.file_path);
      await tx.update(videos)
        .set({ thumbnail_path: thumbnailPath })
        .where(eq(videos.id, video.id));
    }
    
    return importedVideos;
  });
}

// ✅ 正确：错误处理
export async function safeDeleteVideo(videoId: string): Promise<boolean> {
  try {
    return await db.transaction(async (tx) => {
      // 删除相关记录
      await tx.delete(watchHistory).where(eq(watchHistory.video_id, videoId));
      await tx.delete(bookmarks).where(eq(bookmarks.video_id, videoId));
      await tx.delete(playlist_videos).where(eq(playlist_videos.video_id, videoId));
      
      // 删除视频文件
      const video = await tx.select().from(videos).where(eq(videos.id, videoId)).limit(1);
      if (video.length > 0) {
        await FileSystem.deleteAsync(video[0].file_path);
        if (video[0].thumbnail_path) {
          await FileSystem.deleteAsync(video[0].thumbnail_path);
        }
      }
      
      // 删除数据库记录
      await tx.delete(videos).where(eq(videos.id, videoId));
      
      return true;
    });
  } catch (error) {
    console.error('Failed to delete video:', error);
    return false;
  }
}
```

## 5. 文件组织规范

### 5.1 目录结构
```
src/
├── features/              # 功能模块
│   ├── video/            # 视频播放功能
│   │   ├── components/   # 视频相关组件
│   │   ├── hooks/        # 视频相关 hooks
│   │   ├── services/     # 视频相关服务
│   │   ├── types/        # 视频相关类型
│   │   └── utils/        # 视频相关工具
│   ├── playlist/         # 播放列表功能
│   ├── upload/           # 文件上传功能
│   ├── search/           # 搜索功能
│   └── settings/         # 设置功能
├── components/           # 共享组件
│   ├── ui/              # 基础 UI 组件
│   ├── layout/          # 布局组件
│   └── common/          # 通用组件
├── hooks/               # 共享 hooks
├── services/            # 服务层
├── stores/              # Zustand stores
├── db/                  # 数据库相关
│   ├── schema.ts        # 数据库 schema
│   ├── migrations/      # 迁移文件
│   └── queries.ts       # 数据库查询
├── utils/               # 工具函数
├── constants/           # 常量定义
└── types/               # 全局类型
```

### 5.2 文件命名规范

#### 5.2.1 组件文件
```typescript
// ✅ 正确：PascalCase 命名
// components/VideoPlayer.tsx
// components/PlaylistItem.tsx
// components/VideoControls.tsx

// ✅ 正确：index.ts 导出
// components/ui/index.ts
export { Button } from './button';
export { Input } from './input';
export { Card } from './card';
```

#### 5.2.2 工具文件
```typescript
// ✅ 正确：kebab-case 或 camelCase 命名
// utils/video-utils.ts
// utils/file-helper.ts
// utils/date-formatter.ts
```

#### 5.2.3 类型文件
```typescript
// ✅ 正确：types.ts 或 index.ts
// features/video/types/index.ts
// features/video/types/video.ts
// features/video/types/playback.ts
```

## 6. 性能优化规范

### 6.1 React 性能优化

#### 6.1.1 组件优化
```typescript
// ✅ 正确：使用 React.memo 优化渲染
const VideoItem = React.memo<{ video: Video; onPress: () => void }>(({ 
  video, 
  onPress 
}) => {
  return (
    <Pressable onPress={onPress}>
      <Image source={{ uri: video.thumbnailPath }} />
      <Text>{video.title}</Text>
    </Pressable>
  );
});

VideoItem.displayName = 'VideoItem';

// ✅ 正确：使用 useCallback 优化函数
const VideoList = ({ videos }: { videos: Video[] }) => {
  const handleVideoPress = useCallback((videoId: string) => {
    navigation.navigate('VideoPlayer', { videoId });
  }, [navigation]);
  
  return (
    <FlatList
      data={videos}
      renderItem={({ item }) => (
        <VideoItem 
          video={item} 
          onPress={() => handleVideoPress(item.id)} 
        />
      )}
      keyExtractor={(item) => item.id}
    />
  );
};
```

#### 6.1.2 列表优化
```typescript
// ✅ 正确：使用 FlashList 优化长列表
import { FlashList } from '@shopify/flash-list';

const VideoLibrary = () => {
  const { videos } = useVideoStore();
  
  const renderItem = useCallback(({ item }: { item: Video }) => (
    <VideoItem video={item} />
  ), []);
  
  return (
    <FlashList
      data={videos}
      renderItem={renderItem}
      estimatedItemSize={100}
      keyExtractor={(item) => item.id}
      showsVerticalScrollIndicator={false}
    />
  );
};
```

### 6.2 内存管理

#### 6.2.1 视频内存管理
```typescript
// ✅ 正确：及时释放视频资源
const VideoPlayer = ({ video }: { video: Video }) => {
  const videoRef = useRef<Video>(null);
  
  useEffect(() => {
    return () => {
      // 组件卸载时释放资源
      videoRef.current?.unloadAsync();
    };
  }, []);
  
  const handleLoadVideo = useCallback(async () => {
    try {
      if (videoRef.current) {
        await videoRef.current.unloadAsync();
      }
      await videoRef.current?.loadAsync({ uri: video.filePath });
    } catch (error) {
      console.error('Failed to load video:', error);
    }
  }, [video.filePath]);
  
  return (
    <Video
      ref={videoRef}
      source={{ uri: video.filePath }}
      resizeMode={ResizeMode.CONTAIN}
      onPlaybackStatusUpdate={handlePlaybackStatusUpdate}
    />
  );
};
```

#### 6.2.2 图像内存管理
```typescript
// ✅ 正确：图像缓存和内存管理
const useOptimizedImage = (source: ImageSourceProp) => {
  const [cachedSource, setCachedSource] = useState<ImageSourceProp>(source);
  
  useEffect(() => {
    const cacheImage = async () => {
      try {
        // 生成缩略图并缓存
        const thumbnailPath = await generateThumbnail(source.uri);
        setCachedSource({ uri: thumbnailPath });
      } catch (error) {
        console.error('Failed to cache image:', error);
      }
    };
    
    if (source.uri) {
      cacheImage();
    }
  }, [source.uri]);
  
  return cachedSource;
};
```

## 7. 错误处理规范

### 7.1 错误处理策略

#### 7.1.1 全局错误处理
```typescript
// ✅ 正确：全局错误边界
class GlobalErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error?: Error }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Global error caught:', error, errorInfo);
    // 上报错误到监控服务
    reportError(error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <View className="flex-1 items-center justify-center bg-red-500">
          <Text className="text-white text-lg">
            应用出现错误，请重启应用
          </Text>
        </View>
      );
    }
    
    return this.props.children;
  }
}

// ✅ 正确：异步错误处理
const useAsyncOperation = <T, E = Error>(
  operation: () => Promise<T>
) => {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<E | null>(null);
  const [loading, setLoading] = useState(false);
  
  const execute = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await operation();
      setData(result);
      return result;
    } catch (err) {
      const error = err as E;
      setError(error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [operation]);
  
  return { data, error, loading, execute };
};
```

#### 7.1.2 API 错误处理
```typescript
// ✅ 正确：API 错误处理
interface ApiError {
  code: string;
  message: string;
  details?: any;
}

class ApiClient {
  async request<T>(endpoint: string, options?: RequestInit): Promise<T> {
    try {
      const response = await fetch(`${API_BASE_URL}${endpoint}`, {
        headers: {
          'Content-Type': 'application/json',
          ...options?.headers,
        },
        ...options,
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new ApiError(
          errorData.code || 'NETWORK_ERROR',
          errorData.message || 'Network request failed',
          errorData
        );
      }
      
      return await response.json();
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      
      throw new ApiError(
        'NETWORK_ERROR',
        'Network request failed',
        { originalError: error }
      );
    }
  }
}

// ✅ 正确：用户友好的错误提示
const ErrorMessage = ({ error, onRetry }: { 
  error: ApiError | Error; 
  onRetry?: () => void;
}) => {
  const getErrorMessage = (error: ApiError | Error) => {
    if (error instanceof ApiError) {
      switch (error.code) {
        case 'NETWORK_ERROR':
          return '网络连接失败，请检查网络设置';
        case 'FILE_NOT_FOUND':
          return '文件不存在，请重新选择';
        case 'PERMISSION_DENIED':
          return '权限不足，请检查应用权限';
        default:
          return error.message || '操作失败，请稍后重试';
      }
    }
    
    return '操作失败，请稍后重试';
  };
  
  return (
    <View className="items-center p-4">
      <Text className="text-red-500 text-center mb-2">
        {getErrorMessage(error)}
      </Text>
      {onRetry && (
        <Button onPress={onRetry} variant="outline">
          重试
        </Button>
      )}
    </View>
  );
};
```

## 8. 测试规范

### 8.1 单元测试

#### 8.1.1 组件测试
```typescript
// ✅ 正确：组件测试示例
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import { VideoItem } from './VideoItem';

describe('VideoItem', () => {
  const mockVideo = {
    id: '1',
    title: 'Test Video',
    filePath: '/test/video.mp4',
    duration: 60000,
    fileSize: 1024000,
    format: 'mp4',
    createdAt: new Date(),
    updatedAt: new Date(),
    tags: [],
    category: 'test',
    watchProgress: 0,
    isFavorite: false,
    playCount: 0,
  };
  
  it('renders video title and thumbnail', () => {
    const { getByText } = render(
      <VideoItem video={mockVideo} onPress={jest.fn()} />
    );
    
    expect(getByText('Test Video')).toBeTruthy();
  });
  
  it('calls onPress when clicked', () => {
    const mockOnPress = jest.fn();
    const { getByTestId } = render(
      <VideoItem video={mockVideo} onPress={mockOnPress} testID="video-item" />
    );
    
    fireEvent.press(getByTestId('video-item'));
    expect(mockOnPress).toHaveBeenCalledWith(mockVideo.id);
  });
});
```

#### 8.1.2 Hook 测试
```typescript
// ✅ 正确：Hook 测试示例
import { renderHook, act } from '@testing-library/react';
import { useVideoPlayer } from './useVideoPlayer';

describe('useVideoPlayer', () => {
  const mockVideo = {
    id: '1',
    title: 'Test Video',
    filePath: '/test/video.mp4',
    duration: 60000,
    fileSize: 1024000,
    format: 'mp4',
    createdAt: new Date(),
    updatedAt: new Date(),
    tags: [],
    category: 'test',
    watchProgress: 0,
    isFavorite: false,
    playCount: 0,
  };
  
  it('initializes with correct default state', () => {
    const { result } = renderHook(() => useVideoPlayer(mockVideo));
    
    expect(result.current.status.isPlaying).toBe(false);
    expect(result.current.status.position).toBe(0);
    expect(result.current.status.duration).toBe(0);
  });
  
  it('updates playing state when play is called', async () => {
    const { result } = renderHook(() => useVideoPlayer(mockVideo));
    
    await act(async () => {
      await result.current.play();
    });
    
    expect(result.current.status.isPlaying).toBe(true);
  });
});
```

### 8.2 集成测试

#### 8.2.1 数据库测试
```typescript
// ✅ 正确：数据库测试示例
import { db } from '../db';
import { videos } from '../db/schema';

describe('Database Operations', () => {
  beforeEach(async () => {
    // 清空测试数据
    await db.delete(videos);
  });
  
  it('should insert and retrieve video', async () => {
    const videoData = {
      title: 'Test Video',
      file_path: '/test/video.mp4',
      duration: 60000,
      file_size: 1024000,
      format: 'mp4',
    };
    
    const [insertedVideo] = await db.insert(videos).values(videoData).returning();
    
    const [retrievedVideo] = await db
      .select()
      .from(videos)
      .where(eq(videos.id, insertedVideo.id));
    
    expect(retrievedVideo.title).toBe(videoData.title);
    expect(retrievedVideo.file_path).toBe(videoData.file_path);
  });
  
  it('should update video progress', async () => {
    const [video] = await db.insert(videos).values({
      title: 'Test Video',
      file_path: '/test/video.mp4',
      duration: 60000,
      file_size: 1024000,
      format: 'mp4',
    }).returning();
    
    await db.update(videos)
      .set({ watch_progress: 30000 })
      .where(eq(videos.id, video.id));
    
    const [updatedVideo] = await db
      .select()
      .from(videos)
      .where(eq(videos.id, video.id));
    
    expect(updatedVideo.watch_progress).toBe(30000);
  });
});
```

## 9. 文档规范

### 9.1 代码文档

#### 9.1.1 JSDoc 规范
```typescript
// ✅ 正确：函数文档
/**
 * 播放指定的视频
 * @param videoId - 要播放的视频ID
 * @param options - 播放选项
 * @param options.startTime - 开始播放时间（秒）
 * @param options.playbackRate - 播放速度
 * @returns Promise<void>
 * @throws {ApiError} 当视频不存在或播放失败时抛出
 * @example
 * ```typescript
 * await playVideo('video-123', { startTime: 30, playbackRate: 1.5 });
 * ```
 */
export async function playVideo(
  videoId: string,
  options: {
    startTime?: number;
    playbackRate?: number;
  } = {}
): Promise<void> {
  const video = await getVideoById(videoId);
  if (!video) {
    throw new ApiError('VIDEO_NOT_FOUND', 'Video not found');
  }
  
  await playbackService.play(videoId, options);
}

// ✅ 正确：组件文档
/**
 * 视频播放器组件
 * @description 用于播放本地视频文件的组件，支持播放控制、进度条、音量调节等功能
 * @param {Video} video - 要播放的视频对象
 * @param {() => void} [onPlay] - 播放回调函数
 * @param {() => void} [onPause] - 暂停回调函数
 * @param {() => void} [onEnd] - 播放结束回调函数
 * @param {string} [className] - 额外的样式类名
 * @returns {React.ReactElement} 视频播放器组件
 */
export const VideoPlayer: React.FC<VideoPlayerProps> = ({
  video,
  onPlay,
  onPause,
  onEnd,
  className,
}) => {
  // 组件实现
};
```

#### 9.1.2 注释规范
```typescript
// ✅ 正确：有意义的注释
// 检查视频格式是否支持
const supportedFormats = ['mp4', 'mov', 'avi', 'mkv'];
if (!supportedFormats.includes(video.format)) {
  throw new Error(`Unsupported format: ${video.format}`);
}

// ✅ 正确：TODO 注释
// TODO: 实现视频格式转换功能
// TODO: 添加字幕支持

// ✅ 正确：FIXME 注释
// FIXME: 处理内存泄漏问题
// FIXME: 优化大文件加载性能

// ❌ 避免：无意义的注释
// 播放视频
playVideo();

// 设置状态
setState({ loading: true });
```

## 10. 版本控制和协作

### 10.1 Git 规范

#### 10.1.1 提交信息规范
```bash
# ✅ 正确：提交信息格式
<type>(<scope>): <description>

# 类型说明
# feat: 新功能
# fix: 修复bug
# docs: 文档更新
# style: 代码格式调整
# refactor: 代码重构
# test: 测试相关
# chore: 构建或工具相关

# 示例
feat(video): add video playback speed control
fix(player): resolve memory leak in video player
docs(api): update API documentation for video upload
style(ui): improve video player component styling
```

#### 10.1.2 分支管理
```bash
# ✅ 正确：分支命名
feature/video-speed-control
bugfix/memory-leak-player
docs/api-documentation
improvement/ui-performance

# ✅ 正确：分支策略
main          # 主分支，始终保持可发布状态
develop       # 开发分支，集成最新功能
feature/*     # 功能分支
bugfix/*      # Bug修复分支
release/*     # 发布准备分支
```

### 10.2 代码审查

#### 10.2.1 审查清单
- [ ] 代码符合项目编码规范
- [ ] TypeScript 类型定义完整
- [ ] 组件职责单一，耦合度低
- [ ] 性能优化措施到位
- [ ] 错误处理完善
- [ ] 测试覆盖充分
- [ ] 文档更新完整
- [ ] 无安全漏洞
- [ ] Git 提交信息规范

---

**文档版本**: 1.0  
**创建日期**: 2025-08-10  
**最后更新**: 2025-08-10