# 数据库设计文档

## 1. 概述

### 1.1 数据库选择
- **数据库类型**: SQLite
- **ORM**: Drizzle ORM
- **驱动**: Expo SQLite
- **选择理由**: 
  - 本地存储，无需网络连接
  - 轻量级，适合移动应用
  - 良好的 TypeScript 支持
  - 支持事务和并发访问

### 1.2 设计原则
- **规范化**: 避免数据冗余，确保数据一致性
- **性能优化**: 合理的索引设计和查询优化
- **扩展性**: 支持未来功能扩展
- **数据完整性**: 使用约束和触发器保证数据完整性

## 2. 数据库架构

### 2.1 实体关系图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│     videos      │    │   watch_history │    │    playlists    │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ id (PK)         │    │ id (PK)         │    │ id (PK)         │
│ title           │    │ video_id (FK)   │    │ name            │
│ file_path       │    │ position        │    │ description     │
│ thumbnail_path  │    │ duration        │    │ created_at      │
│ duration        │    │ watched_at      │    │ updated_at      │
│ file_size       │    │ completed       │    │ video_count     │
│ format          │    └─────────────────┘    │ is_public       │
│ width           │                           └─────────────────┘
│ height          │
│ created_at      │
│ updated_at      │
│ tags            │
│ category        │
│ watch_progress  │
│ is_favorite     │
│ play_count      │
└─────────────────┘
         │
         │
    ┌────┴─────┐
    │          │
┌─────────┐  ┌─────────────┐
│playlist_videos│  │video_tags   │
├─────────┤  ├─────────────┤
│playlist_id(FK)│  │ video_id(FK) │
│video_id(FK)   │  │ tag_id(FK)   │
│position        │  └─────────────┘
│added_at        │
└─────────┘
```

### 2.2 数据表设计

#### 2.2.1 videos 表
存储视频文件的基本信息和元数据。

```sql
CREATE TABLE videos (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  file_path TEXT NOT NULL UNIQUE,
  thumbnail_path TEXT,
  duration INTEGER NOT NULL, -- 毫秒
  file_size INTEGER NOT NULL, -- 字节
  format TEXT NOT NULL,
  width INTEGER,
  height INTEGER,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  tags TEXT DEFAULT '[]', -- JSON数组
  category TEXT DEFAULT 'uncategorized',
  watch_progress INTEGER DEFAULT 0, -- 秒
  is_favorite BOOLEAN DEFAULT FALSE,
  play_count INTEGER DEFAULT 0,
  last_watched_at TEXT,
  description TEXT,
  rating REAL DEFAULT 0,
  is_archived BOOLEAN DEFAULT FALSE
);

-- 索引
CREATE INDEX idx_videos_created_at ON videos(created_at DESC);
CREATE INDEX idx_videos_category ON videos(category);
CREATE INDEX idx_videos_favorite ON videos(is_favorite);
CREATE INDEX idx_videos_title ON videos(title);
CREATE INDEX idx_videos_watch_progress ON videos(watch_progress);
```

#### 2.2.2 watch_history 表
记录用户的观看历史和进度。

```sql
CREATE TABLE watch_history (
  id TEXT PRIMARY KEY,
  video_id TEXT NOT NULL,
  position INTEGER NOT NULL, -- 当前观看位置（秒）
  duration INTEGER NOT NULL, -- 视频总时长（秒）
  watched_at TEXT DEFAULT CURRENT_TIMESTAMP,
  completed BOOLEAN DEFAULT FALSE,
  watch_time INTEGER DEFAULT 0, -- 观看时长（秒）
  session_id TEXT, -- 观看会话ID
  device_id TEXT, -- 设备ID
  playback_speed REAL DEFAULT 1.0,
  FOREIGN KEY (video_id) REFERENCES videos(id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_watch_history_video_id ON watch_history(video_id);
CREATE INDEX idx_watch_history_watched_at ON watch_history(watched_at DESC);
CREATE INDEX idx_watch_history_session_id ON watch_history(session_id);
CREATE INDEX idx_watch_history_completed ON watch_history(completed);
```

#### 2.2.3 playlists 表
管理用户创建的播放列表。

```sql
CREATE TABLE playlists (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  video_count INTEGER DEFAULT 0,
  is_public BOOLEAN DEFAULT FALSE,
  cover_image_path TEXT,
  total_duration INTEGER DEFAULT 0, -- 总时长（秒）
  play_count INTEGER DEFAULT 0,
  last_played_at TEXT,
  sort_order INTEGER DEFAULT 0,
  tags TEXT DEFAULT '[]' -- JSON数组
);

-- 索引
CREATE INDEX idx_playlists_created_at ON playlists(created_at DESC);
CREATE INDEX idx_playlists_name ON playlists(name);
CREATE INDEX idx_playlists_is_public ON playlists(is_public);
CREATE INDEX idx_playlists_sort_order ON playlists(sort_order);
```

#### 2.2.4 playlist_videos 表
播放列表和视频的关联表。

```sql
CREATE TABLE playlist_videos (
  playlist_id TEXT NOT NULL,
  video_id TEXT NOT NULL,
  position INTEGER NOT NULL,
  added_at TEXT DEFAULT CURRENT_TIMESTAMP,
  added_by TEXT DEFAULT 'user', -- 添加者
  custom_title TEXT, -- 在播放列表中的自定义标题
  custom_thumbnail_path TEXT,
  notes TEXT,
  FOREIGN KEY (playlist_id) REFERENCES playlists(id) ON DELETE CASCADE,
  FOREIGN KEY (video_id) REFERENCES videos(id) ON DELETE CASCADE,
  PRIMARY KEY (playlist_id, video_id)
);

-- 索引
CREATE INDEX idx_playlist_videos_playlist_id ON playlist_videos(playlist_id);
CREATE INDEX idx_playlist_videos_video_id ON playlist_videos(video_id);
CREATE INDEX idx_playlist_videos_position ON playlist_videos(position);
```

#### 2.2.5 video_tags 表
视频标签的关联表，支持多对多关系。

```sql
CREATE TABLE video_tags (
  video_id TEXT NOT NULL,
  tag_id TEXT NOT NULL,
  FOREIGN KEY (video_id) REFERENCES videos(id) ON DELETE CASCADE,
  PRIMARY KEY (video_id, tag_id)
);

-- 索引
CREATE INDEX idx_video_tags_video_id ON video_tags(video_id);
CREATE INDEX idx_video_tags_tag_id ON video_tags(tag_id);
```

#### 2.2.6 tags 表
标签表，用于分类和搜索。

```sql
CREATE TABLE tags (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  color TEXT DEFAULT '#3B82F6', -- 标签颜色
  description TEXT,
  usage_count INTEGER DEFAULT 0,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_tags_name ON tags(name);
CREATE INDEX idx_tags_usage_count ON tags(usage_count DESC);
```

#### 2.2.7 settings 表
用户设置表。

```sql
CREATE TABLE settings (
  id TEXT PRIMARY KEY DEFAULT 'default',
  theme TEXT DEFAULT 'system' CHECK(theme IN ('light', 'dark', 'system')),
  default_playback_speed REAL DEFAULT 1.0,
  default_volume REAL DEFAULT 1.0,
  auto_play BOOLEAN DEFAULT TRUE,
  loop_mode TEXT DEFAULT 'none' CHECK(loop_mode IN ('none', 'single', 'all')),
  show_controls BOOLEAN DEFAULT TRUE,
  enable_gestures BOOLEAN DEFAULT TRUE,
  enable_haptics BOOLEAN DEFAULT TRUE,
  skip_intros BOOLEAN DEFAULT FALSE,
  skip_credits BOOLEAN DEFAULT FALSE,
  preferred_quality TEXT DEFAULT 'auto',
  subtitle_language TEXT DEFAULT 'auto',
  audio_language TEXT DEFAULT 'auto',
  max_cache_size INTEGER DEFAULT 1024, -- MB
  auto_cleanup_cache BOOLEAN DEFAULT TRUE,
  cache_retention_days INTEGER DEFAULT 30,
  data_backup_enabled BOOLEAN DEFAULT FALSE,
  last_backup_at TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_settings_id ON settings(id);
```

#### 2.2.8 folders 表
文件夹结构表，用于组织视频文件。

```sql
CREATE TABLE folders (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  parent_id TEXT, -- 父文件夹ID
  path TEXT NOT NULL UNIQUE,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  is_system_folder BOOLEAN DEFAULT FALSE,
  thumbnail_path TEXT,
  description TEXT,
  sort_order TEXT DEFAULT 'name_asc', -- 排序方式
  view_mode TEXT DEFAULT 'grid', -- 显示模式
  FOREIGN KEY (parent_id) REFERENCES folders(id) ON DELETE SET NULL
);

-- 索引
CREATE INDEX idx_folders_parent_id ON folders(parent_id);
CREATE INDEX idx_folders_path ON folders(path);
CREATE INDEX idx_folders_name ON folders(name);
CREATE INDEX idx_folders_sort_order ON folders(sort_order);
```

#### 2.2.9 folder_videos 表
文件夹和视频的关联表。

```sql
CREATE TABLE folder_videos (
  folder_id TEXT NOT NULL,
  video_id TEXT NOT NULL,
  added_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE CASCADE,
  FOREIGN KEY (video_id) REFERENCES videos(id) ON DELETE CASCADE,
  PRIMARY KEY (folder_id, video_id)
);

-- 索引
CREATE INDEX idx_folder_videos_folder_id ON folder_videos(folder_id);
CREATE INDEX idx_folder_videos_video_id ON folder_videos(video_id);
```

#### 2.2.10 bookmarks 表
视频书签表，用于标记重要时间点。

```sql
CREATE TABLE bookmarks (
  id TEXT PRIMARY KEY,
  video_id TEXT NOT NULL,
  title TEXT NOT NULL,
  position INTEGER NOT NULL, -- 书签位置（秒）
  thumbnail_path TEXT,
  description TEXT,
  color TEXT DEFAULT '#EF4444',
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (video_id) REFERENCES videos(id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_bookmarks_video_id ON bookmarks(video_id);
CREATE INDEX idx_bookmarks_position ON bookmarks(position);
CREATE INDEX idx_bookmarks_created_at ON bookmarks(created_at DESC);
```

## 3. 数据库操作

### 3.1 基础操作

#### 3.1.1 视频操作

```typescript
// Drizzle ORM 操作示例
import { db } from './db';
import { videos, watchHistory, playlists } from './schema';

// 插入视频
export async function insertVideo(videoData: Omit<typeof videos.$inferInsert, 'id'>) {
  const [video] = await db.insert(videos).values(videoData).returning();
  return video;
}

// 查询视频
export async function getVideoById(id: string) {
  const [video] = await db.select().from(videos).where(eq(videos.id, id));
  return video;
}

// 搜索视频
export async function searchVideos(query: string) {
  return db.select()
    .from(videos)
    .where(or(
      ilike(videos.title, `%${query}%`),
      ilike(videos.description, `%${query}%`)
    ))
    .limit(50);
}

// 更新观看进度
export async function updateWatchProgress(videoId: string, position: number) {
  await db.update(videos)
    .set({ 
      watch_progress: position,
      last_watched_at: new Date().toISOString()
    })
    .where(eq(videos.id, videoId));
  
  // 记录观看历史
  await db.insert(watchHistory).values({
    video_id: videoId,
    position,
    duration: (await getVideoById(videoId))?.duration || 0,
    watched_at: new Date().toISOString()
  });
}
```

#### 3.1.2 播放列表操作

```typescript
// 创建播放列表
export async function createPlaylist(name: string, description?: string) {
  const [playlist] = await db.insert(playlists).values({
    name,
    description,
    created_at: new Date().toISOString()
  }).returning();
  return playlist;
}

// 添加视频到播放列表
export async function addVideoToPlaylist(playlistId: string, videoId: string) {
  const position = await db.select({ position: playlist_videos.position })
    .from(playlist_videos)
    .where(eq(playlist_videos.playlist_id, playlistId))
    .orderBy(desc(playlist_videos.position))
    .limit(1);
  
  const nextPosition = position.length > 0 ? position[0].position + 1 : 0;
  
  await db.insert(playlist_videos).values({
    playlist_id: playlistId,
    video_id: videoId,
    position: nextPosition,
    added_at: new Date().toISOString()
  });
  
  // 更新播放列表视频计数
  await db.update(playlists)
    .set({ 
      video_count: sql`${playlists.video_count} + 1`,
      updated_at: new Date().toISOString()
    })
    .where(eq(playlists.id, playlistId));
}
```

### 3.2 复杂查询

#### 3.2.1 统计查询

```typescript
// 获取视频统计信息
export async function getVideoStats() {
  const [stats] = await db.select({
    totalVideos: sql<number>`COUNT(*)`,
    totalDuration: sql<number>`SUM(duration)`,
    totalSize: sql<number>`SUM(file_size)`,
    totalPlayCount: sql<number>`SUM(play_count)`,
    averageRating: sql<number>`AVG(rating)`
  }).from(videos);
  
  return stats;
}

// 获取分类统计
export async function getCategoryStats() {
  return db.select({
    category: videos.category,
    count: sql<number>`COUNT(*)`,
    totalDuration: sql<number>`SUM(duration)`,
    totalSize: sql<number>`SUM(file_size)`
  })
  .from(videos)
  .groupBy(videos.category)
  .orderBy(desc(sql`COUNT(*)`));
}
```

#### 3.2.2 关联查询

```typescript
// 获取播放列表及其视频
export async function getPlaylistWithVideos(playlistId: string) {
  const playlist = await db.select()
    .from(playlists)
    .where(eq(playlists.id, playlistId))
    .limit(1);
  
  if (!playlist.length) return null;
  
  const playlistVideos = await db.select({
    id: videos.id,
    title: videos.title,
    thumbnail_path: videos.thumbnail_path,
    duration: videos.duration,
    position: playlist_videos.position,
    added_at: playlist_videos.added_at
  })
  .from(videos)
  .innerJoin(playlist_videos, eq(videos.id, playlist_videos.video_id))
  .where(eq(playlist_videos.playlist_id, playlistId))
  .orderBy(playlist_videos.position);
  
  return {
    ...playlist[0],
    videos: playlistVideos
  };
}
```

### 3.3 事务处理

```typescript
// 批量导入视频
export async function batchImportVideos(videoDataList: VideoData[]) {
  return db.transaction(async (tx) => {
    const importedVideos = [];
    
    for (const videoData of videoDataList) {
      const [video] = await tx.insert(videos).values(videoData).returning();
      importedVideos.push(video);
      
      // 创建缩略图
      const thumbnailPath = await generateThumbnail(video.file_path);
      await tx.update(videos)
        .set({ thumbnail_path: thumbnailPath })
        .where(eq(videos.id, video.id));
    }
    
    return importedVideos;
  });
}

// 删除播放列表
export async function deletePlaylist(playlistId: string) {
  return db.transaction(async (tx) => {
    // 删除播放列表中的视频关联
    await tx.delete(playlist_videos)
      .where(eq(playlist_videos.playlist_id, playlistId));
    
    // 删除播放列表
    await tx.delete(playlists)
      .where(eq(playlists.id, playlistId));
  });
}
```

## 4. 性能优化

### 4.1 索引策略

#### 4.1.1 主要索引
```sql
-- 视频表索引
CREATE INDEX idx_videos_search ON videos(title, description, tags);
CREATE INDEX idx_videos_performance ON videos(duration, file_size, play_count);
CREATE INDEX idx_videos_category_favorite ON videos(category, is_favorite);

-- 观看历史索引
CREATE INDEX idx_watch_history_performance ON watch_history(video_id, watched_at, completed);

-- 播放列表索引
CREATE INDEX idx_playlists_performance ON playlists(name, is_public, video_count);
```

#### 4.1.2 复合索引
```sql
-- 搜索优化
CREATE INDEX idx_videos_full_text_search ON videos(
  title COLLATE NOCASE,
  description COLLATE NOCASE,
  tags COLLATE NOCASE
);

-- 排序优化
CREATE INDEX idx_videos_sorting ON videos(
  category COLLATE NOCASE,
  created_at DESC,
  play_count DESC
);
```

### 4.2 查询优化

#### 4.2.1 分页查询
```typescript
// 高效分页查询
export async function getVideosPaginated(
  page: number,
  pageSize: number,
  options: {
    category?: string;
    sortBy?: 'created_at' | 'title' | 'duration' | 'play_count';
    sortOrder?: 'asc' | 'desc';
    searchQuery?: string;
  } = {}
) {
  const offset = (page - 1) * pageSize;
  const { category, sortBy = 'created_at', sortOrder = 'desc', searchQuery } = options;
  
  let query = db.select().from(videos);
  
  // 添加过滤条件
  if (category) {
    query = query.where(eq(videos.category, category));
  }
  
  if (searchQuery) {
    query = query.where(or(
      ilike(videos.title, `%${searchQuery}%`),
      ilike(videos.description, `%${searchQuery}%`)
    ));
  }
  
  // 添加排序
  const orderByColumn = {
    created_at: videos.created_at,
    title: videos.title,
    duration: videos.duration,
    play_count: videos.play_count
  }[sortBy];
  
  const orderByDirection = sortOrder === 'desc' ? desc : asc;
  query = query.orderBy(orderByDirection(orderByColumn));
  
  // 获取总数
  const [totalCount] = await db.select({ count: sql<number>`COUNT(*)` }).from(
    query.as('count_query')
  );
  
  // 获取分页数据
  const items = await query.limit(pageSize).offset(offset);
  
  return {
    items,
    total: totalCount.count,
    page,
    pageSize,
    hasNext: offset + pageSize < totalCount.count,
    hasPrev: page > 1
  };
}
```

#### 4.2.2 预加载优化
```typescript
// 预加载相关数据
export async function getVideoWithRelations(videoId: string) {
  const video = await getVideoById(videoId);
  if (!video) return null;
  
  // 并行查询相关数据
  const [watchHistory, playlists, bookmarks] = await Promise.all([
    db.select()
      .from(watchHistory)
      .where(eq(watchHistory.video_id, videoId))
      .orderBy(desc(watchHistory.watched_at))
      .limit(10),
    
    db.select({
      playlist_id: playlist_videos.playlist_id,
      playlist_name: playlists.name,
      position: playlist_videos.position
    })
    .from(playlist_videos)
    .innerJoin(playlists, eq(playlist_videos.playlist_id, playlists.id))
    .where(eq(playlist_videos.video_id, videoId)),
    
    db.select()
      .from(bookmarks)
      .where(eq(bookmarks.video_id, videoId))
      .orderBy(bookmarks.position)
  ]);
  
  return {
    ...video,
    watchHistory,
    playlists,
    bookmarks
  };
}
```

## 5. 数据迁移

### 5.1 迁移文件

```typescript
// drizzle.config.ts
import type { Config } from 'drizzle-kit';

export default {
  schema: './db/schema.ts',
  out: './db/migrations',
  dialect: 'sqlite',
  driver: 'expo',
} satisfies Config;
```

### 5.2 迁移脚本

```typescript
// 数据库初始化
export async function initializeDatabase() {
  try {
    // 检查数据库是否已初始化
    const result = await db.select({ count: sql<number>`COUNT(*)` }).from(sqlite_master);
    
    if (result[0].count === 0) {
      // 运行所有迁移
      await runMigrations();
      
      // 插入默认设置
      await db.insert(settings).values({
        id: 'default',
        theme: 'system',
        default_playback_speed: 1.0,
        default_volume: 1.0,
        auto_play: true,
        loop_mode: 'none',
        show_controls: true,
        enable_gestures: true,
        enable_haptics: true,
        created_at: new Date().toISOString()
      });
      
      // 创建默认文件夹
      await db.insert(folders).values([
        {
          id: 'root',
          name: 'Videos',
          path: '/videos',
          is_system_folder: true,
          created_at: new Date().toISOString()
        },
        {
          id: 'favorites',
          name: 'Favorites',
          path: '/favorites',
          is_system_folder: true,
          created_at: new Date().toISOString()
        }
      ]);
    }
  } catch (error) {
    console.error('Database initialization failed:', error);
    throw error;
  }
}

// 运行迁移
export async function runMigrations() {
  const migrationPath = './db/migrations';
  const migrationFiles = await readdir(migrationPath);
  
  for (const file of migrationFiles.sort()) {
    if (file.endsWith('.sql')) {
      const migrationSQL = await readFile(join(migrationPath, file), 'utf-8');
      await db.run(sql.raw(migrationSQL));
      console.log(`Applied migration: ${file}`);
    }
  }
}
```

## 6. 数据备份和恢复

### 6.1 备份策略

```typescript
// 数据库备份
export async function backupDatabase(): Promise<string> {
  const backupPath = `${FileSystem.documentDirectory}backup_${Date.now()}.db`;
  
  try {
    // 获取当前数据库文件
    const dbPath = `${FileSystem.documentDirectory}videotape.db`;
    
    // 复制数据库文件
    await FileSystem.copyAsync({
      from: dbPath,
      to: backupPath
    });
    
    console.log('Database backup created:', backupPath);
    return backupPath;
  } catch (error) {
    console.error('Database backup failed:', error);
    throw error;
  }
}

// 数据库恢复
export async function restoreDatabase(backupPath: string): Promise<boolean> {
  try {
    const dbPath = `${FileSystem.documentDirectory}videotape.db`;
    
    // 关闭数据库连接
    await db.close();
    
    // 恢复数据库文件
    await FileSystem.copyAsync({
      from: backupPath,
      to: dbPath
    });
    
    // 重新连接数据库
    await connectToDatabase();
    
    console.log('Database restored from:', backupPath);
    return true;
  } catch (error) {
    console.error('Database restore failed:', error);
    return false;
  }
}
```

### 6.2 数据导出

```typescript
// 导出数据为JSON
export async function exportData(): Promise<string> {
  const data = {
    videos: await db.select().from(videos),
    playlists: await db.select().from(playlists),
    settings: await db.select().from(settings),
    exportDate: new Date().toISOString(),
    version: '1.0'
  };
  
  return JSON.stringify(data, null, 2);
}

// 导入JSON数据
export async function importData(jsonData: string): Promise<boolean> {
  try {
    const data = JSON.parse(jsonData);
    
    await db.transaction(async (tx) => {
      // 清空现有数据（保留设置）
      await tx.delete(videos);
      await tx.delete(playlists);
      await tx.delete(watchHistory);
      await tx.delete(bookmarks);
      
      // 导入视频数据
      if (data.videos) {
        for (const video of data.videos) {
          await tx.insert(videos).values(video);
        }
      }
      
      // 导入播放列表数据
      if (data.playlists) {
        for (const playlist of data.playlists) {
          await tx.insert(playlists).values(playlist);
        }
      }
    });
    
    return true;
  } catch (error) {
    console.error('Data import failed:', error);
    return false;
  }
}
```

## 7. 监控和维护

### 7.1 数据库健康检查

```typescript
// 数据库健康检查
export async function checkDatabaseHealth(): Promise<{
  status: 'healthy' | 'warning' | 'error';
  issues: string[];
  stats: {
    tableCount: number;
    totalSize: number;
    indexCount: number;
    lastBackup?: string;
  };
}> {
  const issues: string[] = [];
  
  try {
    // 检查数据库连接
    await db.select({ count: sql<number>`COUNT(*)` }).from(videos);
    
    // 获取数据库统计信息
    const [tableStats] = await db.select({
      count: sql<number>`COUNT(*)`
    }).from(sqlite_master.where(eq(sqlite_master.type, 'table')));
    
    const [indexStats] = await db.select({
      count: sql<number>`COUNT(*)`
    }).from(sqlite_master.where(eq(sqlite_master.type, 'index')));
    
    // 检查数据库文件大小
    const dbPath = `${FileSystem.documentDirectory}videotape.db`;
    const fileInfo = await FileSystem.getInfoAsync(dbPath);
    
    // 检查最后备份时间
    const backupFiles = await FileSystem.readDirectoryAsync(FileSystem.documentDirectory);
    const backupFile = backupFiles
      .filter(file => file.name.startsWith('backup_'))
      .sort((a, b) => b.name.localeCompare(a.name))[0];
    
    return {
      status: issues.length === 0 ? 'healthy' : 'warning',
      issues,
      stats: {
        tableCount: tableStats.count,
        totalSize: fileInfo.size || 0,
        indexCount: indexStats.count,
        lastBackup: backupFile?.name
      }
    };
  } catch (error) {
    return {
      status: 'error',
      issues: ['Database connection failed'],
      stats: {
        tableCount: 0,
        totalSize: 0,
        indexCount: 0
      }
    };
  }
}
```

### 7.2 性能监控

```typescript
// 查询性能监控
export async function monitorQueryPerformance() {
  const queries = [
    { name: 'getVideoById', query: () => getVideoById('test-id') },
    { name: 'searchVideos', query: () => searchVideos('test') },
    { name: 'getVideosPaginated', query: () => getVideosPaginated(1, 20) }
  ];
  
  const results = [];
  
  for (const { name, query } of queries) {
    const start = performance.now();
    try {
      await query();
      const duration = performance.now() - start;
      results.push({ name, duration, status: 'success' });
    } catch (error) {
      const duration = performance.now() - start;
      results.push({ name, duration, status: 'error', error: error.message });
    }
  }
  
  return results;
}
```

---

**文档版本**: 1.0  
**创建日期**: 2025-08-10  
**最后更新**: 2025-08-10